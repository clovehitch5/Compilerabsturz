G = ( N, Z, T, P )

N = {
  Z, Programm, Deklarationsteil, Deklaration, BezeichnerDeklaration,
  Ausfuehrungsteil, AnweisungsBlock, Anweisung, Zuweisung, Inkrementierung,
  BedingteAnweisung, Schleife, ForSchleife, MathematischerAusdruck,
  Summand, Faktor, Operand, BoolescherAusdruck, BoolAnd, Vergleich,
  VergleichsOperator, identifier, int_const, float_const, string_const, Trennlinie, type
}

T = {
  'program', 'begin', 'end', 'if', 'else', 'while', 'for',
  ':', ';', '<=', '++', '--', '+', '-', '*', '/', '(', ')', '<', '>',
  '==', '!=', '&&', '||', ' ', 'A'...'Z', 'a'...'z', '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9'
}

P = {
  Z ::= Programm Deklarationsteil Trennlinie Ausfuehrungsteil

  Programm ::= 'program' identifier ':'

  Deklarationsteil ::= ε | Deklarationsteil Deklaration

  Deklaration ::= type BezeichnerDeklaration
                | type BezeichnerDeklaration '<=' int_const
                | type BezeichnerDeklaration '<=' float_const
                | type BezeichnerDeklaration '<=' string_const

  BezeichnerDeklaration ::= identifier
                          | identifier '<'
                          | identifier '<' string_const
                          | identifier '>'
                          | identifier '<' '>'
                          | identifier '<' string_const '>'

  Ausfuehrungsteil ::= 'begin' AnweisungsBlock 'end'

  AnweisungsBlock ::= ε | AnweisungsBlock Anweisung

  Anweisung ::= Zuweisung
              | BedingteAnweisung
              | Schleife
              | ForSchleife
              | Inkrementierung

  Zuweisung ::= identifier '<=' MathematischerAusdruck

  Inkrementierung ::= identifier '++' | identifier '--'

  MathematischerAusdruck ::= Summand
                           | MathematischerAusdruck '+' Summand 
                           | MathematischerAusdruck '-' Summand

  Summand ::= Faktor
            |  Summand '*' Faktor
            |  Summand '/' Faktor

  Faktor ::= Operand
           | '(' MathematischerAusdruck ')'

  Operand ::= identifier
            | int_const
            | float_const
            | string_const

  BoolescherAusdruck ::= BoolAnd
                       | BoolescherAusdruck '||' BoolAnd

  BoolAnd ::= Vergleich
            | BoolAnd '&&' Vergleich 

  Vergleich ::= identifier VergleichsOperator identifier
              | identifier VergleichsOperator int_const
              | identifier VergleichsOperator float_const
              | identifier VergleichsOperator string_const
              | int_const VergleichsOperator identifier
              | int_const VergleichsOperator int_const
              | int_const VergleichsOperator float_const
              | int_const VergleichsOperator string_const
              | float_const VergleichsOperator identifier
              | float_const VergleichsOperator int_const
              | float_const VergleichsOperator float_const
              | float_const VergleichsOperator string_const
              | string_const VergleichsOperator identifier
              | string_const VergleichsOperator int_const
              | string_const VergleichsOperator float_const
              | string_const VergleichsOperator string_const
              | '(' Vergleich ')'

  VergleichsOperator ::= '<' | '>' | '==' | '!='

  BedingteAnweisung ::= 'if' '(' BoolescherAusdruck ')' ':' AnweisungsBlock 'end'
                      | 'if' '(' BoolescherAusdruck ')' ':' AnweisungsBlock 'else' ':' AnweisungsBlock 'end'

  Schleife ::= 'while' '(' BoolescherAusdruck ')' ':' AnweisungsBlock 'end'

  ForSchleife ::= 'for' '(' ';' BoolescherAusdruck ';' ')' ':' AnweisungsBlock 'end'
                | 'for' '(' Deklaration ';' BoolescherAusdruck ';' ')' ':' AnweisungsBlock 'end'
                | 'for' '(' Deklaration ';' BoolescherAusdruck ';' Anweisung ')' ':' AnweisungsBlock 'end'
                | 'for' '(' ';' BoolescherAusdruck ';' Anweisung ')' ':' AnweisungsBlock 'end'
  
  type ::= 'int'|'float'|'string'
  int_const ::= digit | digit int_const
  float_const ::= int_const '.' int_const
  string_const ::= '"' string_characters '"'
  string_characters ::= ε | string_character string_characters
  string_character ::= letter | digit | ' ' | '_' | '+' | '-' | '*' | '/' | '<' | '>' | '=' | '!' | ':' | ';'
  identifier ::= letter | identifier letter | identifier digit
  digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  letter ::= 'a'...'z' | 'A'...'Z'
}
#### Semantik:

- Variablen müssen deklariert werden, bevor sie verwendet werden.
- Typen sind strikt: keine automatische Konvertierung zwischen Zahlen und Strings.
- `<` und `>` bei Deklarationen kennzeichnen Eingabe bzw. Ausgabe.
- In Schleifen und `wenn`/`dann`-Blöcken dürfen mehrere Anweisungen stehen.
- Leerzeichen werden vollständig durch den Scanner (wie in `SpracheBSP.lark` beschrieben) behandelt.

#### 
- String ist auch in MathematischerAusdruck erlaubt, da es implizit über identifier sowieso geht. Die Stringkonkaternation ist damit abgedeckt und muss nicht extra definiert werden (vermeidet reduce-reduce-Konflikt). Für eine Überprüfung zu welchem Typ der identifier gehört ist eine Kontext nötig, den man bei der syntaktischen Analyse nicht hat. Folglich muss das Problem zu einem späterem Zeitpunkt gelöst werden. Eine vorgegeben Schreibweise für string-Variablen wäre auch eine Lösung, aber wird als unschön und unnötig komliziert für den Neutzer erachtet.
