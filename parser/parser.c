/* Project:  COCKTAIL training
 * Descr:    A recursive Decent Parser for expressions
 * Kind:     The parser (solution)
 * Author:   Dr. Juergen Vollmer <juergen.vollmer@informatik-vollmer.de>
 * $Id: parser.c.in,v 1.5 2017/11/22 10:15:01 vollmer Exp $
 */

#include <stdlib.h>
#include "expr_scan.h"
#include "parser.h"
#include "Errors.h"
/* contains: `Message', `MessageI', `xxFatal', `xxError' */

tToken CurToken;

/*****************************************************************************
 * helpers
 *****************************************************************************/

/* Debugging:  if the C-compiler is called with `-DDEBUG',
 *             some output will be generated
 */
#ifdef DEBUG
#define DEBUG_show(msg) printf("%-5s cur = `%s'\n", msg, token2string(CurToken));
#else
#define DEBUG_show(msg) /* no output */
#endif
static const char *token2string(tToken token)
/* maps token-code to token textual representation */
{
    switch (token)
    {
    case '+':
        return "+";
    case '*':
        return "*";
    case '(':
        return "(";
    case ')':
        return ")";
    case '[':
        return "[";
    case ']':
        return "]";
    case '.':
        return ".";
    case "->":
        return "->";
    case tok_identifier:
        return "identifier";
    case expr_scan_EofToken:
        return "EOF";
    default:
        /* this should never happen */
        MessageI("FATAL ERROR: unknown token", xxFatal,
                 expr_scan_Attribute.Position, xxInteger, (char *)&token);
        abort(); /* aborts the program */
    }
}

/******************************************************************************/

bool match(tToken token)
/* Instead of writing for each token 't' a function 'f_t()', we use
 * 'match (t)'.
 */
{
    DEBUG_show("MATCH");
#ifdef DEBUG
    printf("      cur = `%s' expected = `%s'\n", token2string(CurToken), token2string(token));
#endif
    if (CurToken == token)
    {
        if (CurToken != expr_scan_EofToken)
            CurToken = expr_scan_GetToken();
        DEBUG_show("  new");
        return true;
    }
    else
    {
        char msg[255];
        sprintf(msg, "Syntax Error: found: `%s' expected: `%s'",
                token2string(CurToken), token2string(token));
        Message(msg, xxError, expr_scan_Attribute.Position);
        return false; /* Syntax Error */
    }
}

/*****************************************************************************
 * First-Follow-set Tests
 * 1)  E  ::= T E1                  FIRST (T E1         FOLLOW (E))  = { ( id       }
 * 2)  E1 ::= + T E1                FIRST (+ T E1       FOLLOW (E1)) = { +          }
 * 3)  E1 ::= epsilon               FIRST (epsilon      FOLLOW (E1)) = { eof ) ]    }
 * 4)  T  ::= F T1                  FIRST (F T1         FOLLOW (T))  = { ( id       }
 * 5)  T1 ::= * F T1                FIRST (* F T1       FOLLOW (T1)) = { *          }
 * 6)  T1 ::= epsilon               FIRST (epsilon      FOLLOW (T1)) = { eof ) + ]  }
 * 7)  F  ::= ( E )                 FIRST ( ( E )       FOLLOW (F))  = { (          }
 * 8)  F  ::= D                     FIRST (D            FOLLOW (F))  = { id         }
 * 9)  D  ::= id D1                 FIRST (id D1        FOLLOW (D))  = { id         }
 * 10) D1 ::= . id D1               FIRST (. id D1      FOLLOW (D1)) = { .          }
 * 11) D1 ::= -> id D1              FIRST (-> id D1     FOLLOW (D1)) = { ->         }
 * 12) D1 ::= [ E ] D1              FIRST ([ E ] D1     FOLLOW (D1)) = { [          }
 * 13) D1 ::= epsilon               FIRST (epsilon      FOLLOW (D1)) = { eof * + ] )}
 *
 * //TODO ZÃ¤hlt -> als ein Zeichen oder muss eine Konstante benutzt werden?
 * The function 'FirstFollow_i ()' returns true, if and only if 'CurToken'
 * is element of the appropriate set.
 *
 *   eof   <==> expr_scan_EofToken
 *   id    <==> tok_identifier
 ******************************************************************************/
static bool FirstFollow_1(void)
{
    switch (CurToken)
    {
    case '(':
    case tok_identifier:
        return true;
    default:
        return false;
    }
}

/* fill in the other FirstFollow-functions: FirstFollow_2() .. FirstFollow_8() */

/******************************************************************************
 * We use the following grammar for arithmetic expressions:
 * 1)  E  ::= T E1
 * 2)  E1 ::= + T E1       3)  E1 ::= epsilon
 * 4)  T  ::= F T1
 * 5)  T1 ::= * F T1       6)  T1 ::= epsilon
 * 7)  F  ::= ( E )        8)  F  ::= id
 ******************************************************************************/

/* The function 'f_nt()' for the non-terminal 'nt' returns true, iff
 * 'CurToken' starts a sequence of input-tokens which may be generated by 'nt'.
 * 'CurToken' refers after that to the next token to be processed.
 * Note: eof = end-of-file  is a token too.
 */

bool f_E(void)
{
    DEBUG_show("E");

    if (FirstFollow_1())
        return f_T() && f_E1();
    Message("Syntax Error in <E>", xxError, expr_scan_Attribute.Position);
    return false; /* Syntax Error */
}

/* fill in the functions for the other non-terminals */

/***********************  E  N  D  ***********************************************/